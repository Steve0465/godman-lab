"""
Executor Agent - Executes plans generated by the PlannerAgent.

The ExecutorAgent takes a structured plan and simulates or performs
the actual execution of each step.
"""

from dataclasses import dataclass, field
from typing import Dict
import time


@dataclass
class AgentResponse:
    """
    Standard response format for all agents.
    
    Attributes:
        content: Main response content (text, plan, result, etc.)
        metadata: Additional context and information about the response
    """
    content: str
    metadata: Dict = field(default_factory=dict)


class ExecutorAgent:
    """
    Executor agent that carries out plans from the PlannerAgent.
    
    The executor processes each step in a plan and simulates execution,
    returning results and status information.
    """
    
    def __init__(self, agent_id: str = "executor-001"):
        """
        Initialize the ExecutorAgent.
        
        Args:
            agent_id: Unique identifier for this agent instance
        """
        self.agent_id = agent_id
        self.executions_completed = 0
    
    def execute(self, plan: str) -> AgentResponse:
        """
        Execute a plan from the PlannerAgent.
        
        This is a mock implementation that simulates execution by
        processing the plan text and generating appropriate output.
        
        Args:
            plan: Structured plan string with numbered steps
            
        Returns:
            AgentResponse containing execution results and metadata
            
        Example:
            >>> executor = ExecutorAgent()
            >>> plan = "1. Load data\\n2. Process data\\n3. Save results"
            >>> response = executor.execute(plan)
            >>> print(response.content)
        """
        if not plan or not plan.strip():
            return AgentResponse(
                content="Error: Empty plan",
                metadata={
                    "agent_id": self.agent_id,
                    "status": "error",
                    "error": "Execution plan cannot be empty"
                }
            )
        
        # Increment counter
        self.executions_completed += 1
        
        # Parse plan steps
        steps = self._parse_plan_steps(plan)
        
        if not steps:
            return AgentResponse(
                content="Error: Could not parse plan steps",
                metadata={
                    "agent_id": self.agent_id,
                    "status": "error",
                    "error": "No valid steps found in plan"
                }
            )
        
        # Simulate execution
        execution_results = self._simulate_execution(steps)
        
        # Build result content
        result_lines = [
            "Execution Results:",
            "=" * 50,
            ""
        ]
        
        for i, (step, result) in enumerate(zip(steps, execution_results), 1):
            result_lines.append(f"Step {i}: {step}")
            result_lines.append(f"  Status: {result['status']}")
            if result.get('output'):
                result_lines.append(f"  Output: {result['output']}")
            result_lines.append("")
        
        result_lines.append("=" * 50)
        result_lines.append(f"Total steps executed: {len(steps)}")
        result_lines.append(f"All steps completed successfully")
        
        return AgentResponse(
            content="\n".join(result_lines),
            metadata={
                "agent_id": self.agent_id,
                "agent_type": "executor",
                "status": "success",
                "step_count": len(steps),
                "executions_completed": self.executions_completed,
                "execution_results": execution_results
            }
        )
    
    def _parse_plan_steps(self, plan: str) -> list[str]:
        """
        Parse numbered steps from a plan string.
        
        Args:
            plan: Plan text with numbered steps
            
        Returns:
            List of step descriptions
        """
        steps = []
        for line in plan.split('\n'):
            line = line.strip()
            if not line:
                continue
            # Remove leading numbers and dots (e.g., "1. ", "2. ")
            if line and line[0].isdigit():
                # Find the first space or dot after number
                for i, char in enumerate(line):
                    if char in ['.', ' '] and i > 0:
                        step_text = line[i+1:].strip()
                        if step_text:
                            steps.append(step_text)
                        break
            else:
                # Line without number prefix
                steps.append(line)
        return steps
    
    def _simulate_execution(self, steps: list[str]) -> list[Dict]:
        """
        Simulate execution of plan steps.
        
        In production, this would perform actual operations.
        For now, it generates mock execution results.
        
        Args:
            steps: List of step descriptions
            
        Returns:
            List of execution result dictionaries
        """
        results = []
        
        for step in steps:
            step_lower = step.lower()
            
            # Simulate different outputs based on step content
            if "load" in step_lower or "gather" in step_lower:
                result = {
                    "status": "completed",
                    "output": "Data loaded successfully (mock: 100 records)"
                }
            elif "analyze" in step_lower or "process" in step_lower:
                result = {
                    "status": "completed",
                    "output": "Analysis completed (mock: insights generated)"
                }
            elif "save" in step_lower or "export" in step_lower:
                result = {
                    "status": "completed",
                    "output": "Results saved (mock: /output/results.csv)"
                }
            elif "generate" in step_lower or "create" in step_lower:
                result = {
                    "status": "completed",
                    "output": "Generated successfully (mock: report.pdf)"
                }
            else:
                result = {
                    "status": "completed",
                    "output": "Step executed successfully"
                }
            
            results.append(result)
        
        return results
